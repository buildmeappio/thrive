name: Deploy to Dev

on:
  push:
    branches: [develop]
  pull_request:
    branches: [develop]
  workflow_dispatch:

concurrency:
  group: deploy-dev-${{ github.ref_name }}
  cancel-in-progress: false

permissions:
  id-token: write
  contents: write
  actions: write

jobs:
  ci:
    runs-on: ubuntu-latest
    environment: dev
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm install

      - name: Check linting
        run: npm run lint:check

      - name: Format code
        run: npm run format:check

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Create .env file from AWS Secrets Manager
        run: |
          # Install jq if not available
          sudo apt-get update && sudo apt-get install -y jq || true

          # Fetch secrets from AWS Secrets Manager
          SHARED_SECRET=$(aws secretsmanager get-secret-value --secret-id dev/shared --region ${{ secrets.AWS_REGION }} --query SecretString --output text)
          EXAMINER_SECRET=$(aws secretsmanager get-secret-value --secret-id dev/examiner --region ${{ secrets.AWS_REGION }} --query SecretString --output text)

          # Merge secrets (examiner overrides shared) and convert JSON to .env format
          jq -r -n --argjson shared "$SHARED_SECRET" --argjson examiner "$EXAMINER_SECRET" '$shared * $examiner | to_entries[] | "\(.key)=\(.value | tojson)"' > .env

      - name: Check build
        run: |
          npm run db:generate
          npm run build

      - name: Verify .next directory exists
        if: github.event_name != 'pull_request'
        run: |
          if [ ! -d ".next" ]; then
            echo "âŒ Error: .next directory not found after build"
            exit 1
          fi
          echo "âœ… .next directory found"
          ls -la .next | head -10
          echo "ðŸ“Š .next directory size:"
          du -sh .next

          # Verify critical Next.js build files exist
          if [ ! -f ".next/BUILD_ID" ] && [ ! -d ".next/standalone" ] && [ ! -d ".next/server" ]; then
            echo "âš ï¸ Warning: .next directory exists but missing critical build files"
            find .next -type f | head -20
          fi

      - name: Create deployment tarball
        if: github.event_name != 'pull_request'
        run: |
          echo "ðŸ“¦ Creating deployment tarball..."

          # Create tarball with all required runtime files
          tar -czf deployment.tar.gz \
            .next/ \
            public/ \
            prisma/ \
            package.json \
            package-lock.json \
            next.config.ts \
            tailwind.config.js \
            postcss.config.mjs \
            ecosystem.config.js \
            scripts/ \
            templates/ \
            tsconfig.json \
            prisma.config.ts

          # Verify tarball was created and contains .next
          echo "ðŸ“Š Tarball size:"
          ls -lh deployment.tar.gz

          echo "ðŸ“‹ Verifying .next is in tarball:"
          NEXT_COUNT=$(tar -tzf deployment.tar.gz | grep -E "^\.next" | wc -l)
          if [ "$NEXT_COUNT" -eq 0 ]; then
            echo "âŒ ERROR: .next directory not found in tarball!"
            exit 1
          fi
          echo "âœ… Found $NEXT_COUNT .next entries in tarball (showing first 10):"
          tar -tzf deployment.tar.gz | grep -E "^\.next" | head -10 2>/dev/null || true

          echo "âœ… Deployment tarball created successfully"

      - name: Upload deployment tarball
        uses: actions/upload-artifact@v4
        if: github.event_name != 'pull_request'
        with:
          name: deployment-tarball
          path: deployment.tar.gz
          retention-days: 1

  deploy:
    runs-on: ubuntu-latest
    needs: ci
    if: github.event_name != 'pull_request'
    environment: dev
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Download deployment tarball
        uses: actions/download-artifact@v4
        with:
          name: deployment-tarball
          path: ./

      - name: Verify tarball before deployment
        run: |
          if [ ! -f "deployment.tar.gz" ]; then
            echo "âŒ ERROR: deployment.tar.gz not found!"
            exit 1
          fi

          echo "ðŸ“Š Tarball size:"
          ls -lh deployment.tar.gz

          echo "ðŸ“‹ Verifying .next is in tarball:"
          NEXT_COUNT=$(tar -tzf deployment.tar.gz | grep -E "^\.next" | wc -l)
          if [ "$NEXT_COUNT" -eq 0 ]; then
            echo "âŒ ERROR: .next directory not found in tarball!"
            exit 1
          fi
          echo "âœ… Found $NEXT_COUNT .next entries in tarball (showing first 10):"
          tar -tzf deployment.tar.gz | grep -E "^\.next" | head -10 2>/dev/null || true

          echo "âœ… Tarball verified successfully"

      - name: Copy deployment tarball to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_PORT || 22 }}
          source: "deployment.tar.gz"
          target: "${{ secrets.EC2_DEPLOY_PATH }}/"

      - name: Run deployment script on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_PORT || 22 }}
          script: |
            # Set deployment path and variables
            DEPLOY_PATH="${{ secrets.EC2_DEPLOY_PATH }}"
            AWS_REGION="${{ secrets.AWS_REGION }}"
            APP_NAME="thrive-examiner"

            # Load nvm and use Node.js version 22
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            nvm use 22 || nvm install 22 && nvm use 22

            # Create directory if it doesn't exist
            mkdir -p $DEPLOY_PATH

            # Change to the deployment directory
            cd $DEPLOY_PATH

            # Extract deployment tarball
            echo "ðŸ“¦ Extracting deployment tarball..."
            if [ ! -f "deployment.tar.gz" ]; then
              echo "âŒ ERROR: deployment.tar.gz not found!"
              exit 1
            fi

            # Verify tarball contains .next before extraction
            echo "ðŸ“‹ Verifying .next in tarball:"
            tar -tzf deployment.tar.gz | grep -E "^\.next" | head -10 || {
              echo "âŒ ERROR: .next directory not found in tarball!"
              exit 1
            }

            # Extract tarball
            echo "ðŸ“¤ Extracting files..."
            tar -xzf deployment.tar.gz
            rm -f deployment.tar.gz

            # Critical verification: .next must exist before proceeding
            if [ ! -d ".next" ]; then
              echo "âŒ ERROR: .next directory NOT found after extraction!"
              echo "ðŸ“ Current directory contents:"
              ls -la
              echo "ðŸ“‹ All extracted files:"
              find . -maxdepth 2 -type d | head -20
              exit 1
            fi

            echo "âœ… .next directory found after extraction"
            echo "ðŸ“Š .next directory size:"
            du -sh .next

            # Verify critical Next.js build files
            if [ -f ".next/BUILD_ID" ] || [ -d ".next/standalone" ] || [ -d ".next/server" ]; then
              echo "âœ… Next.js build files verified"
              echo "ðŸ“‹ .next directory structure:"
              ls -la .next | head -15
            else
              echo "âš ï¸ Warning: Some Next.js build files may be missing"
              echo "ðŸ“‹ .next directory contents:"
              find .next -type f | head -20
            fi

            echo "âœ… Deployment tarball extracted successfully"

            # Install jq if not available
            sudo apt-get update && sudo apt-get install -y jq || true

            # Fetch secrets from AWS Secrets Manager
            SHARED_SECRET=$(aws secretsmanager get-secret-value --secret-id dev/shared --region $AWS_REGION --query SecretString --output text)
            EXAMINER_SECRET=$(aws secretsmanager get-secret-value --secret-id dev/examiner --region $AWS_REGION --query SecretString --output text)

            # Merge secrets (examiner overrides shared) and convert JSON to .env format
            jq -r -n --argjson shared "$SHARED_SECRET" --argjson examiner "$EXAMINER_SECRET" '$shared * $examiner | to_entries[] | "\(.key)=\(.value | tojson)"' > .env

            # Install production dependencies
            echo "ðŸ“¦ Installing dependencies..."
            npm install --legacy-peer-deps --include=optional

            # Generate Prisma client
            echo "ðŸ”§ Generating Prisma client..."
            npm run db:generate

            # Make deploy script executable
            chmod +x scripts/deploy.sh || true

            # Run deployment script with skip-build flag
            echo "ðŸš€ Running deployment script..."
            ./scripts/deploy.sh dev --app $APP_NAME --config ecosystem.config.js --env .env --skip-build || {
              # Fallback: Manual PM2 deployment if script fails
              echo "âš ï¸ Deploy script failed, using manual PM2 deployment..."
              
              # Stop existing PM2 process if running
              if pm2 describe "$APP_NAME" > /dev/null 2>&1; then
                echo "ðŸ›‘ Stopping existing PM2 process..."
                pm2 stop "$APP_NAME"
                pm2 delete "$APP_NAME"
              fi

              # Start with PM2
              echo "ðŸš€ Starting PM2..."
              pm2 start ecosystem.config.js --name "$APP_NAME"
              pm2 save
            }

            # Show PM2 status
            echo "ðŸ“Š PM2 Status:"
            pm2 list
            pm2 describe "$APP_NAME" || true
