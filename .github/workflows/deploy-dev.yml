name: Deploy to Dev Environment

on:
  push:
    branches: [develop]
  workflow_dispatch: {}

concurrency:
  group: deploy-dev-${{ github.ref_name }}
  cancel-in-progress: false

permissions:
  id-token: write
  contents: read
  actions: read

env:
  AWS_REGION: ${{ vars.AWS_REGION || 'ca-central-1' }}
  ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
  CONTAINER_NAME: ${{ vars.CONTAINER_NAME || 'examiner-web' }}
  AWS_ROLE_ARN: ${{ vars.AWS_ROLE_ARN }}
  EC2_HOST: ${{ secrets.EC2_HOST }}
  EC2_USER: ${{ secrets.EC2_USER || 'ubuntu' }}
  EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
  SECRET_NAME_DB: ${{ vars.SECRET_NAME_DB || 'dev-db-connection' }}
  SECRET_NAME_ENV: ${{ vars.SECRET_NAME_ENV || 'dev/examiner' }}
  DEPLOY_PATH: ${{ vars.DEPLOY_PATH || '~/examiner' }}

jobs:
  lint:
    name: Lint, Format, Type Check, and Build Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint -- .

      - name: Check formatting
        run: |
          # Check if there are any formatting issues
          npm run lint -- --fix . || true
          if [ -n "$(git diff --name-only)" ]; then
            echo "Code formatting issues detected. Please run 'npm run lint -- --fix' to fix them."
            git diff
            exit 1
          fi

      - name: Type check
        run: npx tsc --noEmit

      - name: Build check
        run: npm run build

  build:
    name: Build and Push Docker Image
    needs: [lint]
    runs-on: ubuntu-latest
    environment: dev
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          role-session-name: github-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}
          audience: sts.amazonaws.com

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create .env file from secrets
        run: |
          cat <<EOF > .env
          ENVIRONMENT=development
          NEXT_PUBLIC_ENVIRONMENT=development
          NEXT_PUBLIC_APP_URL=${{ secrets.NEXT_PUBLIC_APP_URL }}
          NEXT_PUBLIC_CDN_URL=${{ secrets.NEXT_PUBLIC_CDN_URL }}
          NEXT_PUBLIC_GOOGLE_PLACES_API_KEY=${{ secrets.NEXT_PUBLIC_GOOGLE_PLACES_API_KEY }}
          NEXT_PUBLIC_CLAIMANT_AVAILABILITY_URL=${{ secrets.NEXT_PUBLIC_CLAIMANT_AVAILABILITY_URL }}
          EOF

      - name: Build and Push Docker container with tags
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          file: Dockerfile
          tags: |
            ${{ env.ECR_REPOSITORY }}/${{ env.CONTAINER_NAME }}:${{ github.sha }}
            ${{ env.ECR_REPOSITORY }}/${{ env.CONTAINER_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

  deploy:
    name: Deploy to EC2
    needs: [build]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    environment: dev
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          role-session-name: github-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}
          audience: sts.amazonaws.com

      - name: Install dependencies
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Get secrets from AWS Secrets Manager
        id: get-secrets
        run: |
          # Get database connection secret (nested JSON)
          DB_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.SECRET_NAME_DB }} --region ${{ env.AWS_REGION }} --query SecretString --output text)

          # Extract DATABASE_URL from nested JSON (assuming format like {"url": "postgresql://..."})
          DATABASE_URL=$(echo $DB_SECRET | jq -r '.url // .DATABASE_URL // empty')

          # Get other environment variables from dev/examiner secret
          ENV_SECRET=$(aws secretsmanager get-secret-value --secret-id ${{ env.SECRET_NAME_ENV }} --region ${{ env.AWS_REGION }} --query SecretString --output text)

          # Parse JSON secret and convert to .env format
          echo "$ENV_SECRET" | jq -r 'to_entries[] | "\(.key)=\(.value)"' > .env.tmp

          # Add DATABASE_URL if it exists
          if [ ! -z "$DATABASE_URL" ]; then
            echo "DATABASE_URL=$DATABASE_URL" >> .env.tmp
          fi

          # Sort and remove duplicates, keeping DATABASE_URL if it was added
          sort -u -t= -k1,1 .env.tmp > .env
          rm .env.tmp

          echo "::notice::Created .env file with secrets"
          # Don't output the actual secrets for security

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ env.EC2_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ env.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Prepare docker-compose with image tag
        run: |
          # Create a docker-compose file with the specific image tag
          IMAGE_TAG="${{ env.ECR_REPOSITORY }}/${{ env.CONTAINER_NAME }}:${{ github.sha }}"
          cat > docker-compose.deploy.yml << COMPOSE_EOF
          services:
            app:
              image: ${IMAGE_TAG}
              platform: linux/amd64
              container_name: examiner-web
              restart: unless-stopped
              env_file:
                - .env
              environment:
                - NODE_ENV=production
              ports:
                - "3001:3001"
              deploy:
                resources:
                  limits:
                    memory: 2G
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3001/examiner/api/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
          COMPOSE_EOF

      - name: Copy files to EC2
        env:
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
        run: |
          # Expand ~ to home directory on EC2 and create directory
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
            "DEPLOY_PATH='${DEPLOY_PATH}'; mkdir -p \${DEPLOY_PATH/#\~/\$HOME}"
          # Get expanded path for SCP
          REMOTE_PATH=$(ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
            "DEPLOY_PATH='${DEPLOY_PATH}'; echo \${DEPLOY_PATH/#\~/\$HOME}")
          # Copy files to EC2
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            .env \
            docker-compose.deploy.yml \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }}:"${REMOTE_PATH}/"

      - name: Deploy on EC2
        env:
          ECR_REPO: ${{ env.ECR_REPOSITORY }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          IMAGE_TAG: ${{ github.sha }}
          AWS_REGION: ${{ env.AWS_REGION }}
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }} << EOF
            set -e
            
            DEPLOY_PATH="${DEPLOY_PATH}"
            cd \${DEPLOY_PATH/#\~/\$HOME}
            
            # Git pull latest code
            git pull origin develop

            # Login to ECR
            aws ecr get-login-password --region ${AWS_REGION} | \
              docker login --username AWS --password-stdin ${ECR_REPO}
            
            # Pull the latest image
            docker pull ${ECR_REPO}/${CONTAINER_NAME}:${IMAGE_TAG}
            
            # Stop and remove existing container if it exists
            docker-compose -f docker-compose.deploy.yml down || true
            
            # Start the new container
            docker-compose -f docker-compose.deploy.yml up -d
            
            # Wait for container to be healthy
            echo "Waiting for container to be healthy..."
            timeout=120
            elapsed=0
            while [ \$elapsed -lt \$timeout ]; do
              if docker-compose -f docker-compose.deploy.yml ps | grep -q "Up (healthy)"; then
                echo "Container is healthy!"
                exit 0
              fi
              sleep 5
              elapsed=\$((elapsed + 5))
              echo "Health check attempt: \$elapsed seconds elapsed"
            done
            
            # If we get here, health check failed
            echo "Health check failed after \$timeout seconds"
            docker-compose -f docker-compose.deploy.yml logs
            exit 1
          EOF

      - name: Verify deployment
        env:
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }} << EOF
            DEPLOY_PATH="${DEPLOY_PATH}"
            cd \${DEPLOY_PATH/#\~/\$HOME}
            docker-compose -f docker-compose.deploy.yml ps
            docker-compose -f docker-compose.deploy.yml logs --tail=50
          EOF
