name: Deploy to Dev

on:
  push:
    branches: [develop]
  pull_request:
    branches: [develop]
  workflow_dispatch:

concurrency:
  group: deploy-dev-${{ github.ref_name }}
  cancel-in-progress: false

permissions:
  id-token: write
  contents: write
  actions: write

jobs:
  ci:
    runs-on: ubuntu-latest
    environment: dev
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm install

      - name: Check linting
        run: npm run lint:check

      - name: Format code
        run: npm run format:check

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Create .env file from AWS Secrets Manager
        run: |
          # Install jq if not available
          sudo apt-get update && sudo apt-get install -y jq || true

          # Fetch secrets from AWS Secrets Manager
          SHARED_SECRET=$(aws secretsmanager get-secret-value --secret-id dev/shared --region ${{ secrets.AWS_REGION }} --query SecretString --output text)
          ADMIN_SECRET=$(aws secretsmanager get-secret-value --secret-id dev/admin --region ${{ secrets.AWS_REGION }} --query SecretString --output text)

          # Merge secrets (admin overrides shared) and convert JSON to .env format
          jq -r -n --argjson shared "$SHARED_SECRET" --argjson admin "$ADMIN_SECRET" '$shared * $admin | to_entries[] | "\(.key)=\(.value | tojson)"' > .env

      - name: Check build
        run: |
          npm run db:generate
          npm run build

      - name: Verify .next directory exists
        if: github.event_name != 'pull_request'
        run: |
          if [ ! -d ".next" ]; then
            echo "âŒ Error: .next directory not found after build"
            exit 1
          fi
          echo "âœ… .next directory found"
          ls -la .next | head -10
          echo "ðŸ“Š .next directory size:"
          du -sh .next

          # Verify critical Next.js build files exist
          if [ ! -f ".next/BUILD_ID" ] && [ ! -d ".next/standalone" ] && [ ! -d ".next/server" ]; then
            echo "âš ï¸ Warning: .next directory exists but missing critical build files"
            find .next -type f | head -20
          fi

      - name: Create deployment tarball
        if: github.event_name != 'pull_request'
        run: |
          echo "ðŸ“¦ Creating deployment tarball..."

          # Create tarball with all required runtime files
          tar -czf deployment.tar.gz \
            .next/ \
            public/ \
            prisma/ \
            package.json \
            package-lock.json \
            next.config.ts \
            tailwind.config.ts \
            postcss.config.mjs \
            ecosystem.config.js \
            scripts/ \
            templates/ \
            tsconfig.json \
            prisma.config.ts

          # Verify tarball was created and contains .next
          echo "ðŸ“Š Tarball size:"
          ls -lh deployment.tar.gz

          echo "ðŸ“‹ Verifying .next is in tarball:"
          NEXT_COUNT=$(tar -tzf deployment.tar.gz | grep -E "^\.next" | wc -l)
          if [ "$NEXT_COUNT" -eq 0 ]; then
            echo "âŒ ERROR: .next directory not found in tarball!"
            exit 1
          fi
          echo "âœ… Found $NEXT_COUNT .next entries in tarball (showing first 10):"
          tar -tzf deployment.tar.gz | grep -E "^\.next" | head -10 2>/dev/null || true

          echo "âœ… Deployment tarball created successfully"

      - name: Upload deployment tarball
        uses: actions/upload-artifact@v4
        if: github.event_name != 'pull_request'
        with:
          name: deployment-tarball
          path: deployment.tar.gz
          retention-days: 1
  deploy:
    runs-on: ubuntu-latest
    needs: ci
    if: github.event_name != 'pull_request'
    environment: dev
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Download deployment tarball
        uses: actions/download-artifact@v4
        with:
          name: deployment-tarball
          path: ./

      - name: Verify tarball before deployment
        run: |
          if [ ! -f "deployment.tar.gz" ]; then
            echo "âŒ ERROR: deployment.tar.gz not found!"
            exit 1
          fi

          echo "ðŸ“Š Tarball size:"
          ls -lh deployment.tar.gz

          echo "ðŸ“‹ Verifying .next is in tarball:"
          NEXT_COUNT=$(tar -tzf deployment.tar.gz | grep -E "^\.next" | wc -l)
          if [ "$NEXT_COUNT" -eq 0 ]; then
            echo "âŒ ERROR: .next directory not found in tarball!"
            exit 1
          fi
          echo "âœ… Found $NEXT_COUNT .next entries in tarball (showing first 10):"
          tar -tzf deployment.tar.gz | grep -E "^\.next" | head -10 2>/dev/null || true

          echo "âœ… Tarball verified successfully"

      - name: Copy deployment tarball to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_PORT || 22 }}
          source: "deployment.tar.gz"
          target: "${{ secrets.EC2_DEPLOY_PATH }}/"

      - name: Run deployment script on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_PORT || 22 }}
          script: |
            set -e  # Exit on any error

            # Set deployment path and variables
            DEPLOY_PATH="${{ secrets.EC2_DEPLOY_PATH }}"
            RELEASES_DIR="$DEPLOY_PATH/releases"
            CURRENT_LINK="$DEPLOY_PATH/current"
            RELEASE_DIR="$RELEASES_DIR/$(date +%Y%m%d%H%M%S)"
            AWS_REGION="${{ secrets.AWS_REGION }}"
            APP_NAME="thrive-admin"

            echo "ðŸš€ Starting atomic deployment..."
            echo "ðŸ“ DEPLOY_PATH: $DEPLOY_PATH"
            echo "ðŸ“ RELEASES_DIR: $RELEASES_DIR"
            echo "ðŸ“ CURRENT_LINK: $CURRENT_LINK"
            echo "ðŸ“ RELEASE_DIR: $RELEASE_DIR"

            # Load nvm and use Node.js version 22 (fixed command precedence)
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            nvm install 22
            nvm use 22

            # Ensure directories exist
            mkdir -p "$RELEASES_DIR" "$RELEASE_DIR"
            echo "âœ… Created release directory: $RELEASE_DIR"

            # Move deployment tarball into release directory
            if [ ! -f "$DEPLOY_PATH/deployment.tar.gz" ]; then
              echo "âŒ ERROR: deployment.tar.gz not found at $DEPLOY_PATH/deployment.tar.gz!"
              exit 1
            fi

            mv "$DEPLOY_PATH/deployment.tar.gz" "$RELEASE_DIR/deployment.tar.gz"
            echo "âœ… Moved tarball to release directory"

            # Verify tarball contains .next BEFORE extraction
            echo "ðŸ“‹ Verifying .next in tarball before extraction..."
            if ! tar -tzf "$RELEASE_DIR/deployment.tar.gz" | grep -qE "^\.next"; then
              echo "âŒ ERROR: .next directory not found in tarball!"
              echo "ðŸ“‹ Tarball contents:"
              tar -tzf "$RELEASE_DIR/deployment.tar.gz" | head -20
              exit 1
            fi
            echo "âœ… Verified .next exists in tarball"

            # Extract into RELEASE_DIR
            echo "ðŸ“¤ Extracting files into release directory..."
            cd "$RELEASE_DIR"
            tar -xzf deployment.tar.gz
            rm -f deployment.tar.gz
            echo "âœ… Extracted tarball and removed archive"

            # Verify .next exists after extraction + basic Next.js artifact validation
            if [ ! -d ".next" ]; then
              echo "âŒ ERROR: .next directory NOT found after extraction!"
              echo "ðŸ“ Release directory contents:"
              ls -la
              exit 1
            fi

            echo "âœ… .next directory found after extraction"

            # Validate Next.js build artifacts
            if [ ! -f ".next/BUILD_ID" ] && [ ! -d ".next/standalone" ] && [ ! -d ".next/server" ]; then
              echo "âŒ ERROR: Next.js build validation failed!"
              echo "   Missing: .next/BUILD_ID, .next/standalone, and .next/server"
              echo "ðŸ“‹ .next directory contents:"
              ls -la .next | head -20
              exit 1
            fi

            echo "âœ… Next.js build artifacts validated"
            echo "ðŸ“Š .next directory size:"
            du -sh .next

            # Atomically repoint current symlink
            echo "ðŸ”— Atomically switching symlink to new release..."
            ln -sfn "$RELEASE_DIR" "$CURRENT_LINK"

            # Verify symlink points to correct directory
            if [ "$(readlink -f "$CURRENT_LINK")" != "$(readlink -f "$RELEASE_DIR")" ]; then
              echo "âŒ ERROR: Symlink verification failed!"
              exit 1
            fi
            echo "âœ… Symlink switched atomically to: $RELEASE_DIR"

            # Change to current release directory for all subsequent operations
            cd "$CURRENT_LINK"
            echo "ðŸ“ Working directory: $(pwd)"

            # Install jq if not available
            sudo apt-get update && sudo apt-get install -y jq || true

            # Fetch secrets from AWS Secrets Manager
            echo "ðŸ” Fetching secrets from AWS Secrets Manager..."
            SHARED_SECRET=$(aws secretsmanager get-secret-value --secret-id dev/shared --region $AWS_REGION --query SecretString --output text)
            ADMIN_SECRET=$(aws secretsmanager get-secret-value --secret-id dev/admin --region $AWS_REGION --query SecretString --output text)

            # Merge secrets (admin overrides shared) and convert JSON to .env format
            jq -r -n --argjson shared "$SHARED_SECRET" --argjson admin "$ADMIN_SECRET" '$shared * $admin | to_entries[] | "\(.key)=\(.value | tojson)"' > "$CURRENT_LINK/.env"
            echo "âœ… Generated .env file in current release"

            # Install production dependencies
            echo "ðŸ“¦ Installing dependencies in current release..."
            npm install --legacy-peer-deps --include=optional

            # Generate Prisma client
            echo "ðŸ”§ Generating Prisma client in current release..."
            npm run db:generate

            # Make deploy script executable
            chmod +x scripts/deploy.sh || true

            # Run deployment script with skip-build flag from current release
            echo "ðŸš€ Running deployment script from current release..."
            ./scripts/deploy.sh dev --app $APP_NAME --config ecosystem.config.js --env .env --skip-build || {
              # Fallback: Manual PM2 deployment if script fails
              echo "âš ï¸ Deploy script failed, using manual PM2 deployment..."
              
              # Stop existing PM2 process if running
              if pm2 describe "$APP_NAME" > /dev/null 2>&1; then
                echo "ðŸ›‘ Stopping existing PM2 process..."
                pm2 stop "$APP_NAME"
                pm2 delete "$APP_NAME"
              fi

              # Start with PM2 from current release directory
              # Note: cwd is set in ecosystem.config.js using __dirname
              echo "ðŸš€ Starting PM2 from current release..."
              pm2 start "$CURRENT_LINK/ecosystem.config.js" --name "$APP_NAME"
              pm2 save
            }

            # Prune old releases (keep last 3)
            echo "ðŸ§¹ Pruning old releases (keeping last 3)..."
            if [ -d "$RELEASES_DIR" ]; then
              OLD_RELEASES=$(ls -1dt "$RELEASES_DIR"/* 2>/dev/null | tail -n +4 || true)
              if [ -n "$OLD_RELEASES" ]; then
                echo "$OLD_RELEASES" | while read -r old_release; do
                  if [ -n "$old_release" ] && [ -d "$old_release" ]; then
                    echo "ðŸ—‘ï¸  Removing old release: $old_release"
                    rm -rf "$old_release"
                  fi
                done
                echo "âœ… Pruned old releases"
              else
                echo "â„¹ï¸  No old releases to prune"
              fi
            fi

            # Show PM2 status
            echo "ðŸ“Š PM2 Status:"
            pm2 list
            pm2 describe "$APP_NAME" || true

            echo "âœ… Atomic deployment completed successfully!"
            echo "ðŸ“ Current release: $RELEASE_DIR"
            echo "ðŸ”— Symlink: $CURRENT_LINK -> $(readlink -f "$CURRENT_LINK")"
