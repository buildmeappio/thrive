name: Deploy Database Migrations

on:
  push:
    branches:
      - main # Deploy to production
      - staging # Deploy to staging
      - qa # Deploy to QA
      - develop # Deploy to dev

  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to (select 'auto' to detect from branch)"
        required: true
        type: choice
        options:
          - auto
          - develop
          - qa
          - staging
          - prod
      run_seeders:
        description: "Run seeders after migrations?"
        required: true
        type: boolean
        default: true

permissions:
  contents: read # Required to checkout code

jobs:
  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      run_seeders: ${{ steps.set-env.outputs.run_seeders }}
    steps:
      - name: Set Environment
        id: set-env
        run: |
          # Function to determine environment from branch
          determine_env_from_branch() {
            if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
              echo "prod"
            elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
              echo "staging"
            elif [[ "${{ github.ref }}" == "refs/heads/qa" ]]; then
              echo "qa"
            elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
              echo "develop"
            else
              echo "develop"  # Default fallback
            fi
          }

          # Check if this is a manual workflow_dispatch run
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Get environment from branch first
            BRANCH_ENV=$(determine_env_from_branch)
            
            # Use input if provided and not "auto", otherwise use branch-based detection
            if [[ "${{ inputs.environment }}" == "auto" ]]; then
              ENV="$BRANCH_ENV"
            else
              ENV="${{ inputs.environment }}"
              # Map legacy "dev" to "develop" if needed
              if [[ "$ENV" == "dev" ]]; then
                ENV="develop"
              fi
            fi
            
            echo "environment=$ENV" >> $GITHUB_OUTPUT
            echo "run_seeders=${{ inputs.run_seeders }}" >> $GITHUB_OUTPUT
          else
            # Automatic runs based on branch
            ENV=$(determine_env_from_branch)
            echo "environment=$ENV" >> $GITHUB_OUTPUT
            
            # Set run_seeders based on environment
            if [[ "$ENV" == "prod" ]]; then
              echo "run_seeders=false" >> $GITHUB_OUTPUT  # Never auto-run in prod
            else
              echo "run_seeders=true" >> $GITHUB_OUTPUT
            fi
          fi

  run-migrations:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs: [determine-environment]
    environment: ${{ needs.determine-environment.outputs.environment }}

    steps:
      - name: Create .env file on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER || 'ec2-user' }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script_stop: true
          script: |
            source ~/.bashrc 2>/dev/null || source ~/.bash_profile 2>/dev/null || source ~/.profile 2>/dev/null || true
            set -e
            cd ${{ secrets.APP_DIR }}
            if [ -f .env ]; then
              rm .env
            fi

            # Map environment name to proper format
            ENV_NAME="${{ needs.determine-environment.outputs.environment }}"
            case "$ENV_NAME" in
              "develop")
                ENVIRONMENT="development"
                ;;
              "prod")
                ENVIRONMENT="production"
                ;;
              "staging")
                ENVIRONMENT="staging"
                ;;
              "qa")
                ENVIRONMENT="qa"
                ;;
              *)
                ENVIRONMENT="development"
                ;;
            esac

            # Create .env file using printf (more reliable with SSH actions)
            {
              echo "DATABASE_URL=${{ secrets.DATABASE_URL }}"
              echo "DATABASE_SSL_REQUIRED=false"
              echo "NODE_ENV=production"
              echo "ENVIRONMENT=$ENVIRONMENT"
              echo "PG_EXTERNAL_PORT=${{ secrets.PG_EXTERNAL_PORT }}"
              echo "PG_USER=${{ secrets.PG_USER }}"
              echo "PG_PASSWORD=${{ secrets.PG_PASSWORD }}"
              echo "PG_DB=${{ secrets.PG_DB }}"
              echo "DB_USER=${{ secrets.PG_USER }}"
              echo "DB_PASSWORD=${{ secrets.PG_PASSWORD }}"
              echo "DB_NAME=${{ secrets.PG_DB }}"
            } > .env
            if [ -f .env ]; then
              echo "Successfully created .env file with DATABASE_URL and ENVIRONMENT=$ENVIRONMENT"
            else
              echo "ERROR: Failed to create .env file"
              exit 1
            fi

      - name: Run Migrations on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER || 'ec2-user' }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script_stop: true
          script: |
            set -e
            source ~/.bashrc 2>/dev/null || source ~/.bash_profile 2>/dev/null || source ~/.profile 2>/dev/null || true
            export PATH="$HOME/.nvm/versions/node/$(ls -1 $HOME/.nvm/versions/node 2>/dev/null | tail -1)/bin:$PATH" 2>/dev/null || true
            cd ${{ secrets.APP_DIR }}
            echo "ğŸ“¦ Current directory: $(pwd)"
            echo "ğŸ” Checking Node.js installation..."
            which node || echo "âš ï¸  Node.js not found in PATH"
            which npm || echo "âš ï¸  npm not found in PATH"
            which npx || echo "âš ï¸  npx not found in PATH"
            echo "ğŸ” Checking Prisma installation..."
            npm install
            git pull origin ${{ github.ref }}

            # Extract database host and port from DATABASE_URL
            DB_URL="${{ secrets.DATABASE_URL }}"
            DB_HOST=$(echo "$DB_URL" | sed -n 's/.*@\([^:]*\):.*/\1/p')
            DB_PORT=$(echo "$DB_URL" | sed -n 's/.*:\([0-9]*\)\/.*/\1/p' || echo "5432")

            echo ""
            echo "ğŸ” Testing database connectivity from EC2 instance..."
            echo "   Database Host: $DB_HOST"
            echo "   Database Port: $DB_PORT"
            echo ""

            # Check if host is localhost or local IP address
            IS_LOCALHOST=false
            if [ "$DB_HOST" = "localhost" ] || [ "$DB_HOST" = "127.0.0.1" ] || [ "$DB_HOST" = "::1" ] || [[ "$DB_HOST" =~ ^127\. ]]; then
              IS_LOCALHOST=true
              echo "   â„¹ï¸  Database host is localhost/local IP - skipping DNS resolution check"
            fi

            # Test DNS resolution (skip for localhost)
            if [ "$IS_LOCALHOST" = "false" ]; then
              echo "   ğŸ“¡ Testing DNS resolution..."
              if getent hosts "$DB_HOST" >/dev/null 2>&1 || nslookup "$DB_HOST" >/dev/null 2>&1 || host "$DB_HOST" >/dev/null 2>&1; then
                DB_IP=$(getent hosts "$DB_HOST" | awk '{print $1}' | head -1 || echo "")
                echo "   âœ… DNS resolution successful"
                if [ -n "$DB_IP" ]; then
                  echo "   ğŸ“ Resolved IP: $DB_IP"
                fi
              else
                echo "   âŒ DNS resolution failed for $DB_HOST"
                echo "   âš ï¸  This might indicate a network configuration issue"
              fi
            fi

            # Test network connectivity
            echo ""
            echo "   ğŸ”Œ Testing TCP connection to $DB_HOST:$DB_PORT..."
            if command -v nc >/dev/null 2>&1; then
              if timeout 10 nc -zv -w 5 "$DB_HOST" "$DB_PORT" 2>&1; then
                echo "   âœ… Network connection successful"
              else
                echo "   âŒ Network connection failed"
                echo ""
                echo "   ğŸ”§ Troubleshooting steps:"
                echo "   1. Verify RDS security group allows inbound from EC2 security group on port $DB_PORT"
                echo "   2. Verify EC2 instance is in the same VPC as RDS (or VPC peering is configured)"
                echo "   3. Verify network ACLs allow traffic between EC2 and RDS subnets"
                echo "   4. Check if RDS is in a private subnet and EC2 can route to it"
                exit 1
              fi
            elif command -v timeout >/dev/null 2>&1; then
              if timeout 10 bash -c "echo > /dev/tcp/$DB_HOST/$DB_PORT" 2>/dev/null; then
                echo "   âœ… Network connection successful"
              else
                echo "   âŒ Network connection failed"
                echo ""
                echo "   ğŸ”§ Troubleshooting steps:"
                echo "   1. Verify RDS security group allows inbound from EC2 security group on port $DB_PORT"
                echo "   2. Verify EC2 instance is in the same VPC as RDS"
                exit 1
              fi
            else
              echo "   âš ï¸  No network testing tools available (nc/timeout)"
              echo "   âš ï¸  Proceeding with migration attempt..."
            fi

            echo ""
            echo "ğŸ”„ Running Prisma migrations..."
            npx prisma migrate deploy
            echo "âœ… Migrations completed successfully!"

  run-seeders:
    name: Run Database Seeders
    runs-on: ubuntu-latest
    needs: [determine-environment, run-migrations]
    # Run seeders based on environment logic:
    # - Dev/QA/Staging: Auto-run (idempotent, safe)
    # - Production: Only via manual workflow_dispatch
    if: needs.determine-environment.outputs.run_seeders == 'true'
    environment: ${{ needs.determine-environment.outputs.environment }}

    steps:
      - name: Run Seeders on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER || 'ec2-user' }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script_stop: true
          script: |
            source ~/.bashrc 2>/dev/null || source ~/.bash_profile 2>/dev/null || source ~/.profile 2>/dev/null || true
            export PATH="$HOME/.nvm/versions/node/$(ls -1 $HOME/.nvm/versions/node 2>/dev/null | tail -1)/bin:$PATH" 2>/dev/null || true
            cd ${{ secrets.APP_DIR }}
            echo "ğŸ“¦ Current directory: $(pwd)"
            echo "ğŸ” Checking Node.js installation..."
            which node || echo "âš ï¸  Node.js not found in PATH"
            which npm || echo "âš ï¸  npm not found in PATH"
            echo "ğŸ” Checking Prisma installation..."
            if [ ! -d "node_modules" ]; then
              echo "ğŸ“¥ Installing dependencies..."
              npm install
            fi
            git pull origin ${{ github.ref }}
            echo "Generating Prisma client..."
            npx prisma generate
            echo "ğŸŒ± Running Prisma seeders..."
            npm run seed
            echo "âœ… Seeders completed successfully!"
